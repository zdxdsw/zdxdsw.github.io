<!DOCTYPE html>
<html>

<head>
  <!-- Basic -->
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <!-- Mobile Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <!-- Site Metas -->
  <meta name="keywords" content="" />
  <meta name="description" content="" />
  <meta name="author" content="" />

  <title>What is Learning</title>


  <!-- bootstrap core css -->
  <link rel="stylesheet" type="text/css" href="css/bootstrap.css" />
  <!--slick slider stylesheet -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.5.9/slick.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.5.9/slick-theme.min.css" />

  <!-- fonts style -->
  <link href="https://fonts.googleapis.com/css?family=Poppins:400,600,700&display=swap" rel="stylesheet" />
  <!-- slick slider -->

  <link rel="stylesheet" href="css/slick-theme.css" />
  <!-- font awesome style -->
  <link href="css/font-awesome.min.css" rel="stylesheet" />
  <!-- Custom styles for this template -->
  <link href="css/style.css" rel="stylesheet" />
  <!-- responsive style -->
  <link href="css/responsive.css" rel="stylesheet" />
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  <script type="text/javascript"
    src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

</head>

<body class="sub_page">


    <section class="about_section layout_padding ">
      <div class="container">
        
        <div class="row">
          <div class="col-md-12">
            <h2 style='font-family: "AR PL UKai CN", "regular script", "kaiti", "kaishu", "zhengshu", "zhengkai", cursive; font-size: 1.5rem;'>
              I Still Do Not Know What Learning Is
            </h2>
            <div class="detail-box">
              <p>
                This is much less well-written and thus needing a lot of polishing. It is okay if this leaves an impression that my mind is a circus of ridiculous thoughts.
              </p><br><hr><br><p>
                To rephrase the title, I haven't figured out the right way to think about the question of whether learning is computation.
              </p><p>What is learning? The first time I asked this daunting question was Dec 2024. 
                Quickly, I found a satisfying answer from Tom Mitchell's book. 
              </p><p>
                But today this question resurfaced.
              </p><p>
                To provide a bit more context, I watched a P vs NP lecture by Professor Michael Sipser. 
              </p><p>
                I saw it instantly that, for theoretical computer scientists, the very problem they study was a projection of how they live their own professional lives. 
              </p><p>
                Theorem proving is a computational problem.
              </p><p>
                Then proving P‚â†NP is computational problem.
              </p><p>
                If this computational problem is one that requires irreducible search, then don't all theoretical computer scientists have to wait until the end of universe to see the answer?
              </p><p>
                Many of them must be unwilling to accept this. Then they must reflect upon how they search for solutions to a problem, and why their search is much better than brute-force. 
                Reflecting upon how themselves search will inform on the search problems they study.
              </p><p>
                <b>Part I: Good Heuristics </b>
              </p><p>
                One might say scientists search much faster because they have very good heuristics.
              </p><p>
                Then the question becomes one about how they acquired the heuristics. 
                If we incorporate the developmental/training time of a scientist, then that is still much less time complexity than the lifespan of the universe. 
              </p><p>
                But there are many really hard theorem-proving problems successfully figured out by mathematicians. 
                Did mathematicians accomplish them out of pure luck? Or did their heuristics matter a lot? 
                If there weren't a big mistake with abstracting the developmental/training process of a scientist as performing computations, 
                then, we should be able to program a computer to acquire useful heuristics in a simulated developmental/training process and solve the hard search problems. 
                But all we know is that the conclusion describes something really hard. AI scientists already taste how hard it is. 
                But being hard doesn't mean being impossible, or does it? Let's suppose the conclusion is true, i.e. ‚Äúwe should be able to ‚Ä¶‚Äù is true. 
                Then why do AI scientists struggle so much at doing so? Where did they go wrong? ü§Øü§Ø
              </p><p>
                Now let's switch to the opposite side, in which the conclusion is false, i.e. ‚Äúit is impossible to program a computer to ‚Ä¶‚Äù. 
                Then it must follow that the premise is false (cuz the deduction step is valid). 
                That the premise is false translates to ‚Äúthere <i>is</i> a big mistake with abstracting the developmental/training process of a scientist as performing computations‚Äù. 
                Then how can this mistake be articulated? What part of the developmental/training process of a scientist is fundamentally distinct from computation? ü§Øü§Ø
              </p><p>
                It appears that the discussion so far has been hitting ‚Äúdeadends‚Äù, raising questions that are so profound and scary. 
              </p><p>
                <b>Part II: A Non-vanishing Volume of Needles </b>
              <p>
                There is another way of thinking about explanations for why mathematicians can accomplish endeavors that may require 
                a time complexity more than the lifespan of the universe if brute-force search is adopted ‚Äî‚Äî the number of valid proofs can be numerous. 
              </p>
              </p><p>
                So there is not just one needle in a haystack, there are many needles scattered in a valley, 
                and you can find one as long as you "stick around for a bit". From here, I am not sure how to proceed. 
                Because I don't know whether there exists a theorem like "all valid proofs of a theorem are essentially the same", 
                or equivalently "once you found one valid proof to a theorem, you automatically find all other valid proofs". 
                <span style="color: #888">(Such a theorem may or may not assume a fixed language in which proofs are written. 
                But I shall tentatively assume that the language doesn't matter, because there might be a "universal language" and 
                reducing theorem-proving from other languages to this universal language doesn't change the complexity class.)</span>
                If such theorems do exist, then the fact that there are many valid proofs brings zero help. 
                We must (frustratingly) go back to pondering about the two ‚Äúdeadends‚Äù in PART I. 
              </p><p>
                If such theorems do not exist, then perhaps the fact that there are many valid proofs will actually make a difference. 
                And one might be interested in what proportion of the search space is occupied by needles. 
                If the distribution and/or the total volume of needles satisfy a certain property, the search problem will be actually P. 
                Then no wonder many mathematicians with the right amount of developmental/training process, aided by a bit of correct deduction, reached the needles they were looking for.
              </p><p><b>
                Statement: the search problem faced by mathematicians in theorem-proving differs from the search problem faced by a computer-based theorem prover.
              </b></p><p>
                I can see a potential argument for why this statement is true: A mathematician is simultaneously learning about the landscape the problem lies in, 
                and trying out attempts. But a computer-based theorem prover (at least those implementing brute-force search), does not learn from past attempts 
                and does not remember anything from its past attempts. Learning from past attempts is an elusive task, because apparently remembering all the past traces does not work. 
                One has to ‚Äúmake sense‚Äù of past experiences. Then what's involved in ‚Äúmaking sense‚Äù and why does it help transcending the complexity class of brute-force search? 
              </p><p>
                I apologize for my bad wording. What I'm getting at are the nature of learning and whether learning = computation. 
                In the deep learning case, by definition, learning = computation. Then what might give a deep learning model the advantage over brute-force search? 
                Right, data, objective, and the ‚Äúinductive biases‚Äù which could have numerous sources. In this regard, the aforementioned statement invites 
                thinking about how mathematicians and computer-based theorem-provers differ in their data, objective, and inductive biases. 
                And the path ahead for AI scientists lies exactly in finding the good data, objective, and inductive biases. 
              </p><p>
                Daring to cast doubt on this argument may leave us staring down a scary possibility that learning ‚â† computation, 
                where we would have no choice but enduring the necessary pain required to characterize their difference.  
              </p>

            </div>
          </div>
          <!-- <div class="col-md-4 offset-md-2 col-sm-4 offset-sm-2">
            <div class="img-box">
              <br><img src="images/carnegie_music_hall_blossom.jpg" alt=""><br>
            </div>
          </div>
          <div class="col-md-4 col-sm-4">
            <div class="img-box">
              <br><img src="images/carnegie_music_hall_blossom2.jpg" alt=""><br>
            </div>
          </div> -->
        </div>
      </div>
    </section>

    

  </div>

  <!-- footer section -->
  <footer class="container-fluid footer_section">
    <div class="container">
      <div class="col-md-11 col-lg-8 mx-auto">
        <p>First written: Apr 13, 2025
          &copy; <span id="displayYear"></span> @whimsicalyingshan</a>
        </p>
      </div>
    </div>
  </footer>
  <!-- footer section -->

  <!-- jQery -->
  <script  src="js/jquery-3.4.1.min.js"></script>
  <!-- bootstrap js -->
  <script  src="js/bootstrap.js"></script>
  <!-- slick slider -->
  <script  src="https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.5.9/slick.min.js"></script>
  <!-- custom js -->
  <script  src="js/custom.js"></script>
  <!-- Google Map -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCh39n5U-4IoWpsVGUHWdqB6puEkhRLdmI&callback=myMap"></script>
  <!-- End Google Map -->

</body>

</html>